# JavaAdvancedCode
Java进阶训练营第九期毕业总结

1.JVM

技术关键点：

1.内存结构：  

堆 = 年轻代 （Eden区 + S0 + S1） + 老年代

栈 = n个栈帧(操作数栈 + 本地变量表 + class/method指针 + 返回值)

2.JVM参数：

XMS：初始堆内存

XMX：最大堆内存

XSS：线程栈大小

-XX:+HeapDumpOnOutOfMemoryError：内存溢出时自动dump

-XX:HeapDumpPath：内存溢出的dump路径

3.GC策略：

串行GC

并行GC

CMS GC

G1 GC

ZGC

Shenandoah GC

4.工具：

命令行：jps/jinfo/jstat/jheap

第三方：memory analysis/arthas

经验认识：JVM这一模块的重点在于GC策略和参数调优。当然前面的字节码技术、JVM内存结构等也很重要，有了这些才能明白
JVM调优的底层原理，调优的是什么（1.堆内存及各个分代的关系 2.选择合适的GC策略 3.STW时间）。而GC策略这里，则需
要根据情况来选择，如：java8，业务线程比较重要，需要所有线程来处理业务线程，那么可以选择并行GC；对延迟有要求，且
不希望业务线程停掉可以选择 CMS GC；4g以上内存，推荐G1 GC；再大的内存（T级别）推荐升级ZGC/Shenandoah GC。
参数方便，一方面合理分配各个分代的关系，另一方面应增加监控的参数，此外，监测的工具也应该提前准备好，真正出问题的
时候会派上用场。


2.NIO

技术关键点：

1.模型分类：

阻塞I/O模型：用户进程阻塞，直至数据准备好并拷贝完成

非阻塞I/O模型：内核立即返回，CPU继续做其他事，然后用户进程不断询问

I/O复用模型：通过select或pull 轮询，数据到达后，由轮询线程告知用户进程

信号驱动的I/O模型：无轮询，用户进程告诉内核需要什么数据，数据到达后会发送信号给用户进程

异步I/O模型：真正实现全流程的非阻塞，数据准备好并复制到用户空间，然后再发信号给用户进程

2.Netty框架：

异步

事件驱动

基于NIO

经验认识：涉及到I/O的操作比较慢，当有大量的请求进来的时候，NIO的技术就比较关键了，尤其是在多线程多核的时代。
Netty就是一个基于NIO的网络应用开发框架，很好的实现了NIO的三种模型：Reactor单线程模式、非主从Reactor多线
程模式、主从Reactor多线程模式。实际工作中还尚未用到，这一块还未掌握牢固，仍需复习巩固。


3.并发编程

技术关键点：

1.基础接口：

runnable：无返回值

callable：有返回值，可用future接收

2.线程池：

分类：

单线程线程池：newSingleThreadExecutor

固定容量线程池：newFixedThreadPool

可缓存线程池：newCachedThreadPool

定时线程池：newScheduledThreadPool

参数：

核心线程数：corePoolSize

最大线程数：maximumPoolSize

线程空闲超时时间：keepAliveTime

单位：unit

任务队列：workQueue

线程工厂：ThreadFactory

拒绝策略：handler

3.锁：synchronized、lock、condition、lockSupport

4.并发工具类：Semaphore、CountDownLatch、CyclicBarrier

5.并发原子类

6.线程安全类型

7.ThreadLocal

经验认识：并发线程的本质就是充分利用多核CPU，提高程序性能，不可避免的会发生“冲突”，这时就需要使用锁、原子类、线程安全类型等来控制，
确保程序的运行结果与预期结果一致。此外，无休止、不加控制的创建线程可能会导致程序崩溃，适得其反，因此需要线程池来管理线程，需根据程序
的需要创建特定类型的线程池。

4.Spring与ORM框架

技术关键点：

1.AOP：面向切面编程、控制反转（依赖注入）

2.Spring Bean

3.Spring Xml：通过配置完成Bean的注入，通过上下文获取Bean等

4.SpringBoot：简化配置，spring的脚手架

5.Hibernate：全自动ORM框架

6.Mybatis：半自动ORM框架

7.Stream流操作：流操作，本质上还是多线程，可以大幅度简化代码

8.Lambda表达式：语法糖

经验认识：通过AOP技术可以对现有的代码进行增强，可以减少代码的入侵，达到松耦合的目的。利用SpringBoot可以极大程度地简化配置，
很好地集成各种框架和组件。ORM框架上推荐Mybatis，显式的SQL更加灵活，也更容易审查。Stream 和 Lambda 表达式的熟练运用可以很
大程度上减轻代码量，提高开发效率，但对于新人或不熟悉该语法的人来说，阅读上可能有些困难，且处理不好很容易报空指针异常。

5.MySQL 数据库和 SQL

技术关键点：

1.SQL语言

数据查询语言DDL：保留字 SELECT 是 DQL（也是所有 SQL）用得最多的动词，其他 DQL 常用的保留字有 WHERE，ORDER BY，GROUP BY
和 HAVING。

数据操作语言DML：包括动词  INSERT、UPDATE 和  DELETE。它们分别用于添加、修改和删除。

事务控制语言TCL：它的语句能确保被  DML 语句影响的表的所有行及时得以更新。包括COMMIT（提交）命令、SAVEPOINT（保存点）命令、
ROLLBACK（回滚）命令。

数据控制语言DCL：它的语句通过  GRANT 或  REVOKE 实现权限控制，确定单个用户和用户组对数据库对象的访问。某些  RDBMS 可用  
GRANT 或  REVOKE 控制对表单个列的访问。

数据定义语言DDL：其语句包括动词  CREATE,ALTER 和  DROP。在数据库中创建新表或修改、删除表(CREAT TABLE 或  DROP TABLE);
为表加入索引等。

指针控制语言CCL：它的语句，像  DECLARE CURSOR，FETCH INTO 和  UPDATE WHERE CURRENT 用于对 一个或多个表单独行的操作。

2.MySQL事务

事务可靠性模型 ACID：

Atomicity原子性：原子性，一次事务中的操作要么全部成功，要么全部失败。

Consistency一致性：一致性，跨表、跨行、跨事务，数据库始终保持一致状态。

Isolation隔离性： 隔离性，可见性，保护事务不会互相干扰，包含4种隔离级别。

Durability持久性：持久性，事务提交成功后，不会丢数据。如电源故障，系统崩溃。

3.MySQL事务隔离级别

读未提交: READ UNCOMMITTED

读已提交:READ COMMITTED

可重复读:REPEATABLE READ

可串行化:SERIALIZABLE

4.MySQL锁

表级锁

共享意向锁（IS）: 打算在某些行上设置共享锁

排他意向锁（IX）: 打算对某些行设置排他锁

Insert 意向锁: Insert 操作设置的间隙锁

其他：自增锁（AUTO-IN）；LOCK TABLES/DDL

行级锁

记录锁（Record）: 始终锁定索引记录，注意隐藏的聚簇索引

间隙锁（Gap）: 锁住一个范围

临键锁（Next-Key）: 记录锁+间隙锁的组合; 可“锁定”表中不存在记录

谓词锁（Predicat）: 空间索引

5.存储引擎

MyISAM

不支持事务，也不支持外键约束，只支持全文索引，数据文件和索引文件是分开保存的

InnoDB

支持事务，支持4个事务隔离级别

经验认识：MySQL是一个关系型数据库管理系统，MySQL数据库和SQL这一模块的重点在于了解基础的SQL语句，索引，事务。当然MySQL底层
的存储引擎以及相对应的数据结构也很重要，了解了这些才能更好地理解表结构如何设计，SQL如何优化。更进一步地，我们可以将用上mysql
的主从复制，以及与代码结合实现读写分离，从而真正做到实现mysql的高可用。


6.分库分表

技术关键点：

1.数据库拆分：

垂直拆分拆库：将一个数据库，拆分成多个提供不同业务数据处理能力的数据库。

垂直拆分拆表：如果单表数据量过大，还可能需要对单表进行拆分。

水平拆分（按主键分库分表）：水平拆分就是直接对数据进行分片，有分库和分表两个具体方式，但是都只是降低单个节点数据量，但不改变
数据本身的结构。这样对业务系统本身的代码逻辑来说，就不需要做特别大的改动，甚至可以基于一些中间件做到透明。

水平拆分（按时间分库分表）：数据是有时间属性的，所以自然可以按照时间维度来拆分。比如当前数据表和历史数据表，甚至按季度，按月，
按天来划分不同的表。这样我们按照时间维度来查询数据时，就可以直接定位到当前的这个子表。

2.相关的框架和中间件

Java框架:TDDL;Apache ShardingSphere-JDBC

中间件:DRDS;Apache ShardingSphere-Proxy;MyCat/DBLE;Cobar;Vitness;KingShard

3.数据迁移

全量数据导出和导入:业务系统停机;数据库迁移，校验一致性;然后业务系统升级，接入新数据库。

全量+增量:先同步数据到最近的某个时间戳;然后在发布升级时停机维护;再同步最后一段时间（通常是一天）的变化数据;最后升级业务系统，
接入新数据库。

binlog+全量+增量:通过主库或者从库的 binlog 来解析和重新构造数据，实现复制一般需要中间件等工具的支持。可以实现多线程，断点续
传，全量历史和增量数据同步;实现自定义复杂异构数据结构;实现自动扩容和缩容，比如分库分表到单库单表，单库单表到分库分表，分4个库表
到分64个库表。

4.分布式事务协议 XA

应用程序（Application Program ，简称 AP）:用于定义事务边界(即定义事务的开始和结束)，并且在事务边界内对资源进行操作。

资源管理器（Resource Manager，简称 RM）:如数据库、文件系统等，并提供访问资源的方式

事务管理器:（Transaction Manager ，简称 TM）：负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚等。

5.BASE 柔性事务

基本可用（Basically Available）保证分布式事务参与方不一定同时在线。

柔性状态（Soft state）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够察觉。

而最终一致性（Eventually consistent）通常是通过消息传递的方式保证系统的最终一致性。

6.分布式事务 TCC/AT

第一阶段：检查并预留相关资源

第二阶段：根据所有服务业务的 Try 状态来操作，如果都成功，则进行 Confirm 操作，如果任意一个 Try 发生错误，则全部 Cancel


经验总结：单机数据库已经无法适应互联网的发展，分库分表可以降低单个节点的写压力，提升整个系统的数据容量上限。优点：单库（单表）
变小，便于管理和维护；对性能和容量有提升作用；改造后，系统和数据复杂度降低；可以作为微服务改造的基础。缺点：库变多，管理变复杂；
对业务系统有较强的侵入性；改造过程复杂，容易出故障；拆分到一定程度就无法继续拆分；数据迁移问题。

7.RPC和微服务

1.RPC

代理机制：

本地代理存根：stub、本地序列化反序列化、网络通信、远程服务存根：skeleton、调用实际业务服务、原路返回服务结果、返回给本地调用方

RPC原理 

设计上： 共享pojo实体类，接口类

代理上： 采用动态代理 或 AOP

序列化：原生语言、二进制、文本、JSON、XML

网络传输：TCP、SSL、TLS 或 HTTP、HTTPS

查找实现类：注册中心

2.微服务

应用场景：复杂业务场景

最佳实践：遗留系统改造、恰当粒度拆分、扩展立方体、自动化管理、分布式事务、完善健康体系

spring cloud

经验总结：RPC可实现像调用本地方法一样调用远程方法，结合分库分表的知识，可以很大程度上实现系统的解耦，缓解系统的压力。成熟的微服务框架
可使用spring cloud，但是不复杂的系统使用微服务架构可能适得其反，部门的框架组也尝试把系统升级成微服务，但是对于部门和客户方来说，代价
都太大，虽然勉强升级出来，却亏损很多。

8.分布式缓存

技术关键点：

1.redis：
六大使用场景：业务数据缓存、业务数据处理、全局一致计数、高效统计计数、发布订阅与 Stream、分布式锁

2.Sentinel：哨兵模式实现主从切换高可用

3.Cluster：全自动的分库分表

经验总结：合理化使用redis可实现缓存、分布式锁、全局一致性计数、消息、业务数据的处理、session的过期、秒杀等，这当然离不开redis的高可用
-哨兵模式，这样才能采用redis来作为缓存中间件，另外，必要时可采用分库分表，进一步缓解redis集群的压力。研究了下项目的源码，事实上，项目组
也在使用redis，但并没有实现高可用与分库分表，且放在了同一台服务器上，显然是不合理的。



9.分布式消息队列

技术关键点：

1.Kafka:分布式的，基于发布/订阅的消息系统

broker：Kafka 集群包含一个或多个服务器，这种服务器被称为broker（服务器代理）

Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为topic。（物理上不同的topic的消息分开存储， 逻辑上一个topic的消息
虽然保存于一个或者多个broker上，但用户只需指定消息的topic即可生产或消费数据而不必关心数据存于何处）

partition：partition是物理上的概念，每个topic包含一个或者多个partition

producer：生产者

consumer：消费者

consumer group：消费者组，每个consumer属于一个特定的consumer group（）

2.RabbitMQ:

queue：队列

exchange：交换器

routekey：绑定queue和exchange的key

binding：

3.RocketMQ:作为Kafaka的Java语言重新实现版，没太大本质区别

纯java开发，不需要zk

支持延迟投递，消息追溯 （意义不大）

多个队列使用一个日志文件，所以不存在kafka过多topic问题

经验总结：消息队列具有异步通信、系统解耦、削峰平谷、可靠通信等优点，合理话的采用消息队列，可以很大程度上减少系统因为消息而产生的开销，
并且对于不同系统之间的消息传递起到了很好的解耦作用，大家只需要把消息都发送到消息队列中，就可以异步的发送到想要传递到的系统，并且不会因为
某一台系统的宕机或网络波动而导致多个系统因消息发不出去而产生的业务停滞。



